#!/usr/bin/env node

var util = require("util");
var fs   = require("fs");
var PEG  = require("../lib/peg");

/* Helpers */

function printVersion() {
  util.puts("PEG.js " + PEG.VERSION);
}

function printHelp() {
  util.puts("Usage: pegjs [options] [--] [<input_file>] [<output_file>]");
  util.puts("");
  util.puts("Generates a parser from the PEG grammar specified in the <input_file> and");
  util.puts("writes it to the <output_file>.");
  util.puts("");
  util.puts("If the <output_file> is omitted, its name is generated by changing the");
  util.puts("<input_file> extension to \".js\". If both <input_file> and <output_file> are");
  util.puts("omitted, standard input and output are used.");
  util.puts("");
  util.puts("Options:");
  util.puts("  -e, --export-var <variable>        name of the variable where the parser");
  util.puts("                                     object will be stored (default:");
  util.puts("                                     \"module.exports\")");
  util.puts("      --cache                        make generated parser cache results");
  util.puts("      --allowed-start-rules <rules>  comma-separated list of rules the generated");
  util.puts("                                     parser will be allowed to start parsing");
  util.puts("                                     from (default: the first rule in the");
  util.puts("                                     grammar)");
  util.puts("  -v, --version                      print version information and exit");
  util.puts("  -h, --help                         print help and exit");
}

function exitSuccess() {
  process.exit(0);
}

function exitFailure() {
  process.exit(1);
}

function abort(message) {
  util.error(message);
  exitFailure();
}

/* Arguments */

var args = process.argv.slice(2); // Trim "node" and the script path.

function isOption(arg) {
  return /^-/.test(arg);
}

function nextArg() {
  args.shift();
}

/* Files */

function readStream(inputStream, callback) {
  var input = "";
  inputStream.on("data", function(data) { input += data; });
  inputStream.on("end", function() { callback(input); });
}

/* Main */

/* This makes the generated parser a CommonJS module by default. */
var exportVar = "module.exports";
var options = {
  cache:              false,
  output:             "source"
};

while (args.length > 0 && isOption(args[0])) {
  switch (args[0]) {
    case "-e":
    case "--export-var":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the -e/--export-var option.");
      }
      exportVar = args[0];
      break;

    case "--cache":
      options.cache = true;
      break;

    case "--allowed-start-rules":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the -e/--allowed-start-rules option.");
      }
      options.allowedStartRules = args[0]
        .split(",")
        .map(function(s) { return s.trim() });
      break;

    case "-v":
    case "--version":
      printVersion();
      exitSuccess();
      break;

    case "-h":
    case "--help":
      printHelp();
      exitSuccess();
      break;

    case "--":
      nextArg();
      break;

    default:
      abort("Unknown option: " + args[0] + ".");
  }
  nextArg();
}

switch (args.length) {
  case 0:
    process.stdin.resume();
    var inputStream = process.stdin;
    var outputStream = process.stdout;
    break;

  case 1:
  case 2:
    var inputFile = args[0];
    var inputStream = fs.createReadStream(inputFile);
    inputStream.on("error", function() {
      abort("Can't read from file \"" + inputFile + "\".");
    });

    var outputFile = args.length == 1
      ? args[0].replace(/\.[^.]*$/, ".js")
      : args[1];
    var outputStream = fs.createWriteStream(outputFile);
    outputStream.on("error", function() {
      abort("Can't write to file \"" + outputFile + "\".");
    });

    break;

  default:
    abort("Too many arguments.");
}

readStream(inputStream, function(input) {
  try {
    var source = PEG.buildParser(input, options);
  } catch (e) {
    if (e.line !== undefined && e.column !== undefined) {
      abort(e.line + ":" + e.column + ": " + e.message);
    } else {
      abort(e.message);
    }
  }

  outputStream.write(exportVar + " = " + source + ";\n");
  if (outputStream !== process.stdout) {
    outputStream.end();
  }
});
